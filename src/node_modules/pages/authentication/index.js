import React, {useState, useEffect, useContext} from 'react' //useState позволяет хранить данные (например логин и пароль) и их читать
import {Link, Navigate} from 'react-router-dom'
import useFetch from 'hooks/useFetch'
import useLocalStorage from 'hooks/useLocalStorage'
import {CurrentUserContext} from '../../context/currentUser'

//https://conduit.productionready.io/api/users/login

const Authentication = props => { // counter теперь это локальная переменная внутри Authentication, которую можно использовать где угодно
	const [isSuccessfullSubmit, setIsSuccessfullSubmit] = useState(false)
	
	const isLogin = isSuccessfullSubmit;
	const [token, setToken] = useLocalStorage('token')

	const pageTitle = (token) ? 'Sign In' : 'Sign Up'
	const descriptionLink = (token) ? '/register' : '/login'
	const descriptionText = (token) ? 'У Вас уже есть аккаунт, введите свои логин и пароль.' : 'У Вас еще нет аккаунта, зарегистрируйтесь!'
	const apiUrl = (token) ? '/users/login' : '/users'
	const [email, setEmail] = useState(''); //эта строчка создает хук внутри нашей компонеты.  Создаю состояние для этого counter, эта строчка создает хук внутри нашей компоненты, значение по умочанию будет 0. setCount это функция которая меняет значение counte. т.е. фактически counter это State, а setCount это setState
	const [username, setUsername] = useState('');
	const [password, setPassword] = useState(''); //эта строчка создает хук внутри нашей компонеты.  Создаю состояние для этого counter, эта строчка создает хук внутри нашей компоненты, значение по умочанию будет 0. setCount это функция которая меняет значение counte. т.е. фактически counter это State, а setCount это setState
						// useState всегда возвращает массив из двух элементов, и первый элемент это State и второй элемент это сеттер, у меня это массив из двух элементов [counter, setCount]
	//const [isSubmitting, setIsSubmitting] = useState(false); //создаю дополнительное состояние isSubmitting, по умолчанию фолс
	const [{response, isLoading, error}, doFetch] = useFetch(apiUrl)
	const [currentUserState, setCurrentUserState] = useContext(CurrentUserContext)
	console.log('currentUserState', currentUserState)
	
	console.log('token', token)
	console.log('isLogin', isLogin)
	console.log('descriptionText', descriptionText)
	console.log('descriptionLink', descriptionLink)
	console.log('apiUrl', apiUrl)
	console.log('pageTitle', pageTitle)
	console.log('currentUserState', currentUserState)

	const handleSubmit = (event) => { //html5 валидация, проверяеть что email валидный
		event.preventDefault() //отменяю дефолтное поведение формы в браузере
		//console.log('data', email, password)
		//setIsSubmitting(true) //делаю состояние isSubmitting = true когда отправляю форму
		
		const user = isLogin ? {email, password} : {email, password, username}

		doFetch({ //передаю в doFetch обьект: метод пост и данные пользователя
			method: 'post',
			data: {
				user
			}
		})
	}

	useEffect((isLogin) => {
		if (!response) {
			return
		}
		//localStorage.setItem('token', response.user.token)
		setToken(response.user.token)
		setIsSuccessfullSubmit(true)
		setCurrentUserState(state => ({
			...state, 
			isLoggedIn: true, 
			isLoading: false, 
			currentUser: response.user
		}))

		console.log('response1', response)
		//history.push('/')


		isLogin = (response) ? true : false;
		console.log('isLogin1', isLogin)
	}, [response])

	if (isSuccessfullSubmit) {
		return <Navigate to="/" />
	}


	return (
		<div className='auth-page'>
			<div className='container page'>
				<div className='row'>
					<div className='col-md-6 offset-md-3 col-xs-12'> {/* форма будет внутри по центру. занимаю 6 колонок из 12, а на маленьком экране центрируется и занимает всю ширину */}
						<h1 className='text-xs-center'>{pageTitle}</h1>
						<p className='text-xs-center'>
							<Link to={descriptionLink}>{descriptionText}</Link>
						</p>
						<form onSubmit={handleSubmit}>
							<fieldset>

								{!token && (
									<fieldset className='form-group'>
									<input //каждый раз когда я пишу в инпут, происходит ререндер компонента
										type='text' 
										value={username} 
										//при изменении я хочу читать из ивента значение этого поля и вызывать setEmail
										onChange={e => setUsername(e.target.value)} //вызываю setEmail и передаю внутрь значение моего инпута
										className='form-control form-control-lg' 
										placeholder='Username'/>
								</fieldset>
								)}

								<fieldset className='form-group'>
									<input //каждый раз когда я пишу в инпут, происходит ререндер компонента
										type='email' 
										value={email} 
										//при изменении я хочу читать из ивента значение этого поля и вызывать setEmail
										onChange={e => setEmail(e.target.value)} //вызываю setEmail и передаю внутрь значение моего инпута
										className='form-control form-control-lg' 
										placeholder='Email'/>
								</fieldset>
								
								<fieldset className='form-group'>
									<input 
										type='password' 
										value={password} 
										onChange={e => setPassword(e.target.value)}
										className='form-control form-control-lg' 
										placeholder='Password'/>
								</fieldset>

								<button 
									className='btn btn-lg btn-primary pull-xs-right' 
									type='submit'
									disabled={isLoading} //пока запрос отправляется - кнопка не активная, не нужно думать о том что пользователь кликнет слишком много раз
								>{pageTitle}</button>

							</fieldset>
						</form>
					</div>
				</div>
			</div>
		</div>
	)
}

export default Authentication

//хуки позволяют хранить состояние между ререндерами (перерисовками), каждый раз когда компонент ререндерится мы получаем новое значение из этого юзе стейта
//компоненты могут перерисовываться только когда меняются состояния (state) или пропсы, в данном случае меняется state с помощью useState
//благодаря хукам useState у нас каждый раз новая функция с новыми пропсами
//обычный бутстрап, создаю container потом row потом колонки