import {useState, useEffect} from 'react'
import axios from 'axios'
import useLocalStorage from 'hooks/useLocalStorage'

export default url => {
	const baseUrl = 'https://conduit.productionready.io/api'
	const [isLoading, setIsLoading] = useState(false)
	const [response, setResponse] = useState(null)
	const [error, setError] = useState(null)
	const [options, setOptions] = useState({})  //по умолчанию пустой обьект
	const [token] = useLocalStorage('token') //получаем токен из локал стореж 
	console.log('token', token)

	const doFetch = ( options = {} ) => {
		setOptions(options)    //setOptions и в нее передаю options которые мы получили, после этого options которые мы используем в axios это стали options которые мы создали в useState
		setIsLoading(true)
	} //если у нас есть функция и мы хотим из нее передать данные напривер в useEffect то чаще все используют дополнительный стейт для того чтобы передать данные



			//useEffect вызввается после каждого ререндера(каждое нажатие в инпуте делает ререндер и вызывает useEffect).  Первый раз когда initial render когда компонент зарендерился первый раз и потом каждый раз когда компонент перерендерился
			//внутри useEffect есть доступ ко всем переменным которые обьявлены внутри компонента (например доступ к емейл и паролю)
	useEffect(() => { //можно написать тру и запрос отработает
		const requestOptions = {
			...options, 
			...{
				headers: {
					authorization: token ? `Token ${token}` : ''
				}
			}
		}
		if (!isLoading) { //вызываю при каждом перерендере и проверяю - собмиттим ли мы форму
			return
		}
		
		//первым ключем указываю url который является публичным api и второй параметр это обьект с полями, и если не указываем этот обьект то для axios это будет get reques
		axios(baseUrl + url, requestOptions)
		  .then(res => {
			console.log('succes', res)
			setIsLoading(false)
			setResponse(res.data) //записываю в состояния когда ответ получен то что получили внутри data
		}).catch(error => {
			console.log('error', error)
			setIsLoading(false)
			setError(error.response.data) //если есть ошибка, туда записываю error.response.data, все ошибки от бекенда будут записаны в это состояние
		})
	}, [isLoading, options, url, token]) //хочу вызывать useEffect только когда меняется isLoading, если этот массив не поставить тут то useEffect будет вызываться при каждом перерендере
	//console.log('email', email, password);

	return [{isLoading, response, error}, doFetch]
}

//создаю хук useFetch, он возвращает все данные которые нужны снаружи